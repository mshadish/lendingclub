/**
  * Scala main implementation
  * facilitates acquisition and storage of LendingClub data via LendingClub API
  *
  * 1) Hit the LendingClub API using environment credentials
  *     to get data on owned notes
  *
  * 2) Store note data in a SQL database (in this case we're using SQLite)
  *     for any new information
  */

object Tables extends {
  /**
    * Tables schema is generated by Slick
    * and allows us to interact with the database
    */
  val profile = slick.driver.SQLiteDriver
} with pkg_table.Tables

// date import
import java.util.Calendar
// HTTP imports
import scalaj.http._
import scala.util.parsing.json._
// slick imports
import Tables.NotesStgRow
import Tables.NotesStg
import Tables.profile.api._
// concurrent imports
import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}
// other imports
import scala.language.postfixOps



object Sqlite extends App {
  /**
    * Main implementation
    */

  /** DEFINE DATA ACQUISITION FROM LENDINGCLUB API */
  val future_http_response: Future[HttpResponse[String]] = Future {
    /**
      * Future value to represent the future response from the LendingClub API
      * showing the info on held notes
      */
    // first, lendingclub user ID for the API call is in the environment LENDINGCLUB_USER variable
    // will run get (instead of getOrElse) to throw compile-time error if var isn't properly defined
    val lendingclub_user: String = sys.env.get("LENDINGCLUB_USER").get
    // build the URL using the user id
    val lendingclub = Http("https://api.lendingclub.com/api/investor/v1/accounts/" + lendingclub_user + "/notes")

    // get the authorization, also set up as an environment variable LENDINGCLUB_AUTH
    // will run get (instead of getOrElse) to throw compile-time error if var isn't properly defined
    val lendingclub_auth: String = sys.env.get("LENDINGCLUB_AUTH").get
    // with the proper authorization, we can now set up the call
    // return a Future string http response
    lendingclub.header("Content-Type", "application/json").header("Authorization", lendingclub_auth).asString
  }


  /** DEFINE DATABASE VALUES */
  // get the URI from an environment variable called LENDINGCLUB_DB...
  val uri = sys.env.get("LENDINGCLUB_DB").get
  // ...use predefined URI to access the database
  val db = Database.forURL(uri, driver="org.sqlite.JDBC")


  /** DEFINE HELPER DATE FUNCTION */
  def dateConvert(inval: String): java.sql.Date = {
    /**
      * Helper function to convert a date in string representation (yyyy-MM-dd)
      * to a Date type
      */
    // date parser will expect yyyy-mm-dd format
    val dateParser = new java.text.SimpleDateFormat("yyyy-MM-dd")
    // use the defined parser and return
    val java_type_date = dateParser.parse(inval)
    new java.sql.Date(java_type_date.getTime)
  }


  /** DEFINE DATA TRANSFORMATION, DATABASE UPDATE */
  val database_update: Future[Unit] = future_http_response map {
    /**
      * Future value to process the response from the LendingClub API
      *
      * We expect it to come back as a JSON string, which we'll parse
      * and update our specified database as necessary
      */
    lend_response => {

      // parse the response from the LendingClub API as a JSON string...
      val parsed_level1: Map[String, Any] = JSON.parseFull(lend_response.body)
          .getOrElse("")
          // we're expecting this to be represented as a Map
          // in which we can find the "myNotes" key
          // e.g. {'myNotes': [{'loanId': 1, ...},{'loanId': 2, ...}, ....]}
          .asInstanceOf[Map[String, Any]]

      // ...and convert to a list of notes
      val all_notes: List[Map[String, Any]] = parsed_level1
        // get the myNotes key
        .get("myNotes")
        .getOrElse("")
        // we're expecting the value from the myNotes key to be a list of maps
        // where each map in this List is a single loan
        .asInstanceOf[List[Map[String, Any]]]


      // now we can parse out each note map into the core components we need
      // Loan ID, Loan Status, when the status was updated, and when the loan was ordered
      val lendingclub_notes: List[(Option[Double], Option[String], Option[java.sql.Date], Option[java.sql.Date])] =
        all_notes map (x =>
          (
            // Loan ID
            (x get "loanId").asInstanceOf[Option[Double]],
            // Loan Status
            (x get "loanStatus").asInstanceOf[Option[String]],
            // Status date, when the status was posted
            Option(dateConvert((x get "loanStatusDate" get).asInstanceOf[String])),
            // when the loan was ordered
            Option(dateConvert((x get "orderDate" get).asInstanceOf[String]))
          )
        )


      // UPDATE THE DATABASE
      // using today's date to specify when we obtained the note data
      val today = new java.sql.Date(Calendar.getInstance.getTime.getTime)

      // in order to leverage the case class used to define a row in a Notes Stg table
      // we must adhere to the schema as set in Tables.scala
      val notes_to_insert = (lendingclub_notes map (a => NotesStgRow(a._1, a._2, a._3, Option(today), a._4)))

      // 1) Insert data into the staging table
      Await.result(db.run(NotesStg ++= notes_to_insert), Duration.Inf)

      // 2) Upsert from the staging table into the Notes table
      //     keyed on the Loan ID (shows the latest status for each note)
      Await.result(db.run(sqlu"""
        insert or replace into notes (id, status, status_date, crawl_date, issue_date)
        select id, status, status_date, crawl_date, issue_date from notes_stg
      """), Duration.Inf)

      // 3) Upsert from the staging table into the Notestable
      //     keyed on the Loan ID and status date (shows all statuses for a note over time)
      Await.result(db.run(sqlu"""
        insert or replace into notes_hist (id, status, status_date, crawl_date, issue_date)
        select id, status, status_date, crawl_date, issue_date from notes_stg
      """), Duration.Inf)

      // 4) Clear out the staging table
      Await.result(db.run(sqlu"delete from notes_stg"), Duration.Inf)
    }
  }
  // Bringing everything together
  Await.result(database_update, Duration.Inf)
}